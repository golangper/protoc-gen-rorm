package main

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	proto "github.com/gogo/protobuf/proto"
	descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
	"github.com/gogo/protobuf/protoc-gen-gogo/generator"
	ppb "github.com/gogo/protobuf/protoc-gen-gogo/plugin"
	rorm "github.com/golangper/protoc-gen-rorm/plugin"
)

const genDebug = false

func main() {
	var buf bytes.Buffer
	_, err := buf.ReadFrom(os.Stdin)
	if err != nil {
		panic(fmt.Errorf("error reading from stdin: %v", err))
	}
	out, err := codeGenerator(buf.Bytes())
	if err != nil {
		panic(err)
	}
	os.Stdout.Write(out)
}

func codeGenerator(b []byte) ([]byte, error) {
	req := ppb.CodeGeneratorRequest{}
	err := proto.Unmarshal(b, &req)
	if err != nil {
		return nil, fmt.Errorf("error unmarshaling CodeGeneratorRequest: %v", err)
	}
	resp := gen(&req)
	out, err := proto.Marshal(resp)
	if err != nil {
		return nil, fmt.Errorf("error marshaling CodeGeneratorResponse: %v", err)
	}
	return out, nil
}

func gen(req *ppb.CodeGeneratorRequest) *ppb.CodeGeneratorResponse {
	resp := &ppb.CodeGeneratorResponse{}
	fileToGenerate := map[string]bool{}
	for _, f := range req.FileToGenerate {
		fileToGenerate[f] = true
	}
	for _, file := range req.ProtoFile {
		if !fileToGenerate[file.GetName()] {
			continue
		}
		f := &ppb.CodeGeneratorResponse_File{}

		fext := filepath.Ext(file.GetName())
		fname := strings.TrimSuffix(file.GetName(), fext) + ".service.pb.ts"
		f.Name = proto.String(fname)

		b := &bytes.Buffer{}
		w := &writer{b, 0}
		writeFile(w, file)
		f.Content = proto.String(b.String())
		resp.File = append(resp.File, f)
	}
	return resp
}

func writeFile(w *writer, file *descriptor.FileDescriptorProto) {

	w.p("// Generated by the protocol buffer compiler.  DO NOT EDIT!")
	w.p("// Source: %s", file.GetName())
	w.ln()
	w.p(`import { Injectable } from '@angular/core';`)
	w.p(`import { HttpClient, HttpParams, HttpHeaders, HttpErrorResponse } from '@angular/common/http';`)
	w.p(`import { Observable, throwError } from 'rxjs';`)
	w.p(`import { catchError } from 'rxjs/operators';`)

	// Messages, recurse.
	for _, msg := range file.MessageType {
		if len(msg.Field) == 0 {
			continue
		}
		w.ln()
		w.p(`export interface %s {`, generator.CamelCase(msg.GetName()))
		for _, field := range msg.GetField() {
			tp := getTsFieldType(field.GetType())
			if tp == "" {
				fmt.Println("not support the type", field.GetType())
				return
			}
			if tp == "Object" {
				s := strings.Split(field.GetTypeName(), ".")
				tp = s[len(s)-1]
			}
			lb := field.GetLabel()
			fname := getFieldName(field.GetName())
			str := fname + "?: " + tp
			if lb == descriptor.FieldDescriptorProto_LABEL_REPEATED {
				str += "[]"
			}
			str += ";"
			w.p(str)
		}
		w.p(`}`)

	}

	w.ln()
	w.p(`const httpOptions = {`)
	w.p(`headers: new HttpHeaders({'Content-Type':  'application/json'})`)
	w.p(`};`)

	for _, svc := range file.GetService() {
		cfg := rorm.GetApiCfgExtension(svc.Options)
		if cfg == nil || cfg.Url == "" {
			fmt.Println("must config the api_cfg and url can not be null")
			return
		}
		w.ln()
		if cfg != nil && cfg.Provide != "" {
			w.p(`@Injectable({`)
			w.p(`providedIn: '%s'`, cfg.Provide)
			w.p(`})`)
		} else {
			w.p(`@Injectable()`)
		}
		w.p(`export class %sService {`, generator.CamelCase(svc.GetName()))
		w.p(`url = '%s';`, cfg.GetUrl())
		w.p(`constructor(private http: HttpClient) { }`)
		for _, m := range svc.GetMethod() {
			api := rorm.GetApiExtension(m.Options)
			if api != nil {
				mname := m.GetName()
				in := generator.CamelCase(rorm.GetMessageName(m.GetInputType()))
				out := generator.CamelCase(rorm.GetMessageName(m.GetOutputType()))
				msg := file.GetMessage(rorm.GetMessageName(m.GetInputType()))
				outmsg := file.GetMessage(rorm.GetMessageName(m.GetOutputType()))
				if len(outmsg.Field) == 0 {
					out = "{}"
				}
				w.ln()
				if len(msg.Field) == 0 {
					w.p(`%s(): Observable<%s> {`, mname, out)
				} else {
					w.p(`%s(param: %s): Observable<%s> {`, mname, in, out)
				}

				if api.GetMethod() == `get` || api.GetMethod() == `GET` || api.GetMethod() == `Get` {
					if len(msg.Field) != 0 {
						w.p(`const params = new HttpParams();`)
						for _, f := range msg.Field {
							fname := getFieldName(f.GetName())
							w.p(`params.set('%s', '' + param.%s);`, fname, fname)
						}
						w.p(`return this.http.get<%s>(this.url + '%s', {params: params})`, out, api.GetPath())
					} else {
						w.p(`return this.http.get<%s>(this.url + '%s')`, out, api.GetPath())
					}

					w.p(`  .pipe(`)
					w.p(`    catchError(this.handleError)`)
					w.p(`  );`)

				} else if api.GetMethod() == `post` || api.GetMethod() == `Post` || api.GetMethod() == `POST` {
					w.p(`return this.http.post<%s>(this.url + '%s', param, httpOptions)`, out, api.GetPath())
					w.p(`  .pipe(`)
					w.p(`    catchError(this.handleError)`)
					w.p(`  );`)
				}

				w.p(`}`)
			}

		}
		w.ln()
		w.p(`private handleError(error: HttpErrorResponse) {`)
		w.p(`if (error.error instanceof ErrorEvent) {`)
		w.p(`console.error('An error occurred:', error.error.message);`)
		w.p(`} else {`)
		w.p("console.error(`Backend returned code ${error.status},body was: ${error.error}`);")
		w.p(`}`)
		w.p(`return throwError('Something bad happened; please try again later.');`)
		w.p(`}`)
		w.p(`}`)
	}
}

func getFieldName(str string) string {
	s := generator.CamelCase(str)
	f := strings.ToLower(s[:1])
	return string(f) + string(s[1:])
}
func getTsFieldType(typeID descriptor.FieldDescriptorProto_Type) string {
	m := make(map[descriptor.FieldDescriptorProto_Type]string)
	m[descriptor.FieldDescriptorProto_TYPE_DOUBLE] = "number"    // TYPE_DOUBLE
	m[descriptor.FieldDescriptorProto_TYPE_FLOAT] = "number"     // TYPE_FLOAT
	m[descriptor.FieldDescriptorProto_TYPE_INT64] = "number"     // TYPE_INT64
	m[descriptor.FieldDescriptorProto_TYPE_UINT64] = "number"    // TYPE_UINT64
	m[descriptor.FieldDescriptorProto_TYPE_INT32] = "number"     // TYPE_INT32
	m[descriptor.FieldDescriptorProto_TYPE_FIXED64] = "number"   // TYPE_FIXED64
	m[descriptor.FieldDescriptorProto_TYPE_FIXED32] = "number"   // TYPE_FIXED32
	m[descriptor.FieldDescriptorProto_TYPE_BOOL] = "boolean"     // TYPE_BOOL
	m[descriptor.FieldDescriptorProto_TYPE_STRING] = "string"    // TYPE_STRING
	m[descriptor.FieldDescriptorProto_TYPE_MESSAGE] = "Object"   // TYPE_MESSAGE - Length-delimited aggregate.
	m[descriptor.FieldDescriptorProto_TYPE_BYTES] = "Uint8Array" // TYPE_BYTES
	m[descriptor.FieldDescriptorProto_TYPE_UINT32] = "number"    // TYPE_UINT32
	m[descriptor.FieldDescriptorProto_TYPE_ENUM] = "number"      // TYPE_ENUM
	m[descriptor.FieldDescriptorProto_TYPE_SFIXED32] = "number"  // TYPE_SFIXED32
	m[descriptor.FieldDescriptorProto_TYPE_SFIXED64] = "number"  // TYPE_SFIXED64
	m[descriptor.FieldDescriptorProto_TYPE_SINT32] = "number"    // TYPE_SINT32 - Uses ZigZag encoding.
	m[descriptor.FieldDescriptorProto_TYPE_SINT64] = "number"    // TYPE_SINT64 - Uses ZigZag encoding.
	return m[typeID]
}

// writer is a little helper for output printing. It indents code
// appropriately among other things.
type writer struct {
	w io.Writer
	i int
}

func (w *writer) p(format string, a ...interface{}) {
	if strings.HasPrefix(format, "}") {
		w.i--
	}
	i := w.i
	if i < 0 {
		i = 0
	}
	indent := strings.Repeat("  ", i)
	fmt.Fprintf(w.w, indent+format, a...)
	w.ln()
	if strings.HasSuffix(format, "{") {
		w.i++
	}
}

func (w *writer) ln() {
	fmt.Fprintln(w.w)
}

func (w *writer) pdebug(format string, a ...interface{}) {
	if !genDebug {
		return
	}
	w.p(fmt.Sprintf(`console.log("PROTOC-DEBUG: %s");`, format), a...)
}
